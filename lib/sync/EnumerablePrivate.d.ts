import { IGrouping, IEqualityComparer, ITuple, IAsyncEqualityComparer } from "../shared/shared";
import { IEnumerable } from "./sync";
import { BasicEnumerable } from "./BasicEnumerable";
import { IAsyncEnumerable } from "./../async/async";
/**
 * @throws {InvalidOperationException} No Elements
 */
export declare function aggregate_1<TSource>(source: Iterable<TSource>, func: (x: TSource, y: TSource) => TSource): TSource | null;
export declare function aggregate_2<TSource, TAccumulate>(source: Iterable<TSource>, seed: TAccumulate, func: (x: TAccumulate, y: TSource) => TAccumulate): TAccumulate;
export declare function aggregate_3<TSource, TAccumulate, TResult>(source: Iterable<TSource>, seed: TAccumulate, func: (x: TAccumulate, y: TSource) => TAccumulate, resultSelector: (x: TAccumulate) => TResult): TResult;
export declare function any_1<TSource>(source: Iterable<TSource>): boolean;
export declare function any_2<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => boolean): boolean;
export declare function average_1(source: Iterable<number>): number;
export declare function average_2<TSource>(source: Iterable<TSource>, func: (x: TSource) => number): number;
export declare function count_1<T>(source: Iterable<T>): number;
export declare function count_2<T>(source: Iterable<T>, predicate: (x: T) => boolean): number;
export declare function first_1<T>(source: Iterable<T>): T;
export declare function first_2<T>(source: Iterable<T>, predicate: (x: T) => boolean): T;
export declare function firstOrDefault_1<T>(source: Iterable<T>): T | null;
export declare function firstOrDefault_2<T>(source: Iterable<T>, predicate: (x: T) => boolean): T | null;
export declare function groupBy_0_Simple<TSource>(source: Iterable<TSource>, keySelector: ((x: TSource) => string) | ((x: TSource) => number)): IEnumerable<IGrouping<string | number, TSource>>;
export declare function groupBy_0<TSource, TKey>(source: Iterable<TSource>, keySelector: (x: TSource) => TKey, comparer: IEqualityComparer<TKey>): IEnumerable<IGrouping<TKey, TSource>>;
export declare function groupByAsync_0_Simple<TSource>(source: Iterable<TSource>, keySelector: (x: TSource) => Promise<any>): IAsyncEnumerable<IGrouping<any, TSource>>;
export declare function groupByAsync_0<TSource, TKey>(source: Iterable<TSource>, keySelector: (x: TSource) => Promise<TKey> | TKey, comparer: IEqualityComparer<TKey> | IAsyncEqualityComparer<TKey>): IAsyncEnumerable<IGrouping<TKey, TSource>>;
export declare function groupBy_1_Simple<TSource, TElement>(source: Iterable<TSource>, keySelector: (x: TSource) => string | number, elementSelector: (x: TSource) => TElement): IEnumerable<IGrouping<string | number, TElement>>;
export declare function groupBy_1<TSource, TKey, TElement>(source: Iterable<TSource>, keySelector: (x: TSource) => TKey, elementSelector: (x: TSource) => TElement, comparer: IEqualityComparer<TKey>): IEnumerable<IGrouping<TKey, TElement>>;
export declare function groupBy_2_Simple<TSource, TResult>(source: Iterable<TSource>, keySelector: ((x: TSource) => string) | ((x: TSource) => number), resultSelector: (x: string | number, values: IEnumerable<TSource>) => TResult): IEnumerable<TResult>;
export declare function groupBy_2<TSource, TKey, TResult>(source: Iterable<TSource>, keySelector: (x: TSource) => TKey, resultSelector: (x: TKey, values: IEnumerable<TSource>) => TResult, comparer?: IEqualityComparer<TKey>): IEnumerable<TResult>;
export declare function groupBy_3_Simple<TSource, TElement, TResult>(source: Iterable<TSource>, keySelector: ((x: TSource) => string) | ((x: TSource) => number), elementSelector: (x: TSource) => TElement, resultSelector: (key: string | number, values: IEnumerable<TElement>) => TResult): IEnumerable<TResult>;
export declare function groupBy_3<TSource, TKey, TElement, TResult>(source: Iterable<TSource>, keySelector: (x: TSource) => TKey, elementSelector: (x: TSource) => TElement, resultSelector: (key: TKey, values: IEnumerable<TElement>) => TResult, comparer?: IEqualityComparer<TKey>): IEnumerable<TResult>;
export declare function select_1<TSource, TResult>(source: Iterable<TSource>, selector: (x: TSource) => TResult): IEnumerable<TResult>;
export declare function select_2<TSource, TKey extends keyof TSource>(source: Iterable<TSource>, key: TKey): IEnumerable<TSource[TKey]>;
export declare function selectAsync_1<TSource, TResult>(source: Iterable<TSource>, selector: (x: TSource) => Promise<TResult>): IAsyncEnumerable<TResult>;
export declare function selectAsync_2<TSource extends {
    [key: string]: Promise<TResult>;
}, TKey extends keyof TSource, TResult>(source: Iterable<TSource>, key: TKey): IAsyncEnumerable<TResult>;
export declare function selectMany_1<TSource, TResult>(source: Iterable<TSource>, selector: (x: TSource) => Iterable<TResult>): IEnumerable<TResult>;
export declare function selectMany_2<TSource extends {
    [key: string]: Iterable<TResult>;
}, TResult>(source: Iterable<TSource>, selector: keyof TSource): BasicEnumerable<TResult>;
export declare function single_1<TSource>(source: Iterable<TSource>): TSource;
export declare function single_2<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => boolean): TSource;
export declare function singleOrDefault_1<TSource>(source: Iterable<TSource>): TSource | null;
export declare function singleOrDefault_2<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => boolean): TSource | null;
export declare function skipWhile_1<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => boolean): IEnumerable<TSource>;
export declare function skipWhile_2<TSource>(source: Iterable<TSource>, predicate: (x: TSource, index: number) => boolean): IEnumerable<TSource>;
export declare function skipWhileAsync_1<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => Promise<boolean>): IAsyncEnumerable<TSource>;
export declare function skipWhileAsync_2<TSource>(source: Iterable<TSource>, predicate: (x: TSource, index: number) => Promise<boolean>): IAsyncEnumerable<TSource>;
export declare function last_1<TSource>(source: Iterable<TSource>): TSource;
export declare function last_2<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => boolean): TSource;
export declare function lastOrDefault_1<TSource>(source: Iterable<TSource>): TSource | null;
export declare function lastOrDefault_2<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => boolean): TSource | null;
export declare function max_1(source: Iterable<number>): number;
export declare function max_2<TSource>(source: Iterable<TSource>, selector: (x: TSource) => number): number;
export declare function min_1(source: Iterable<number>): number;
export declare function min_2<TSource>(source: Iterable<TSource>, selector: (x: TSource) => number): number;
export declare function sum_1(source: Iterable<number>): number;
export declare function sum_2<TSource>(source: Iterable<TSource>, selector: (x: TSource) => number): number;
export declare function takeWhile_1<T>(source: Iterable<T>, predicate: (x: T) => boolean): IEnumerable<T>;
export declare function takeWhile_2<T>(source: Iterable<T>, predicate: (x: T, index: number) => boolean): IEnumerable<T>;
export declare function takeWhileAsync_1<T>(source: Iterable<T>, predicate: (x: T) => Promise<boolean>): IAsyncEnumerable<T>;
export declare function takeWhileAsync_2<T>(source: Iterable<T>, predicate: (x: T, index: number) => Promise<boolean>): IAsyncEnumerable<T>;
export declare function union_1<TSource>(first: Iterable<TSource>, second: Iterable<TSource>): BasicEnumerable<TSource>;
export declare function union_2<TSource>(first: Iterable<TSource>, second: Iterable<TSource>, comparer: IEqualityComparer<TSource>): BasicEnumerable<TSource>;
export declare function where_1<T>(source: Iterable<T>, predicate: (x: T) => boolean): IEnumerable<T>;
export declare function where_2<T>(source: Iterable<T>, predicate: (x: T, index: number) => boolean): IEnumerable<T>;
export declare function whereAsync_1<T>(source: Iterable<T>, predicate: (x: T) => Promise<boolean>): IAsyncEnumerable<T>;
export declare function whereAsync_2<T>(source: Iterable<T>, predicate: (x: T, index: number) => Promise<boolean>): IAsyncEnumerable<T>;
export declare function zip_1<T, Y>(source: Iterable<T>, second: Iterable<Y>): IEnumerable<ITuple<T, Y>>;
export declare function zip_2<T, Y, OUT>(source: Iterable<T>, second: Iterable<Y>, resultSelector: (x: T, y: Y) => OUT): IEnumerable<OUT>;
