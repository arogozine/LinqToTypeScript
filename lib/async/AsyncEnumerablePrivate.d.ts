import { IAsyncEqualityComparer, IEqualityComparer, IGrouping, ITuple } from "./../shared/shared";
import { BasicAsyncEnumerable } from "./BasicAsyncEnumerable";
import { IAsyncEnumerable } from "./IAsyncEnumerable";
export declare function groupBy_0_Simple<TSource>(source: AsyncIterable<TSource>, keySelector: ((x: TSource) => string) | ((x: TSource) => number)): IAsyncEnumerable<IGrouping<string | number, TSource>>;
export declare function groupBy_0<TSource, TKey>(source: AsyncIterable<TSource>, keySelector: (x: TSource) => TKey, comparer: IEqualityComparer<TKey>): IAsyncEnumerable<IGrouping<TKey, TSource>>;
export declare function groupByAsync_0_Simple<TSource>(source: AsyncIterable<TSource>, keySelector: (x: TSource) => Promise<any>): IAsyncEnumerable<IGrouping<any, TSource>>;
export declare function groupByAsync_0<TSource, TKey>(source: AsyncIterable<TSource>, keySelector: (x: TSource) => Promise<TKey> | TKey, comparer: IEqualityComparer<TKey> | IAsyncEqualityComparer<TKey>): IAsyncEnumerable<IGrouping<TKey, TSource>>;
export declare function groupBy_1_Simple<TSource, TElement>(source: AsyncIterable<TSource>, keySelector: (x: TSource) => string | number, elementSelector: (x: TSource) => TElement): IAsyncEnumerable<IGrouping<string | number, TElement>>;
export declare function groupBy_1<TSource, TKey, TElement>(source: AsyncIterable<TSource>, keySelector: (x: TSource) => TKey, elementSelector: (x: TSource) => TElement, comparer: IEqualityComparer<TKey>): IAsyncEnumerable<IGrouping<TKey, TElement>>;
export declare function select_1<TSource, TResult>(source: AsyncIterable<TSource>, selector: (x: TSource) => TResult): IAsyncEnumerable<TResult>;
export declare function select_2<TSource, TKey extends keyof TSource>(source: AsyncIterable<TSource>, key: TKey): IAsyncEnumerable<TSource[TKey]>;
export declare function selectAsync_1<TSource, TResult>(source: AsyncIterable<TSource>, selector: (x: TSource) => Promise<TResult>): IAsyncEnumerable<TResult>;
export declare function selectAsync_2<TSource extends {
    [key: string]: Promise<TResult>;
}, TKey extends keyof TSource, TResult>(source: AsyncIterable<TSource>, key: TKey): IAsyncEnumerable<TResult>;
export declare function selectMany_1<TSource, Y>(source: AsyncIterable<TSource>, selector: (x: TSource) => Iterable<Y>): IAsyncEnumerable<Y>;
export declare function selectMany_2<TSource extends {
    [key: string]: Iterable<Y>;
}, Y>(source: AsyncIterable<TSource>, selector: keyof TSource): IAsyncEnumerable<Y>;
export declare function skipWhile_1<TSource>(source: AsyncIterable<TSource>, predicate: (x: TSource) => boolean): IAsyncEnumerable<TSource>;
export declare function skipWhile_2<TSource>(source: AsyncIterable<TSource>, predicate: (x: TSource, index: number) => boolean): IAsyncEnumerable<TSource>;
export declare function skipWhileAsync_1<TSource>(source: AsyncIterable<TSource>, predicate: (x: TSource) => Promise<boolean>): IAsyncEnumerable<TSource>;
export declare function skipWhileAsync_2<TSource>(source: AsyncIterable<TSource>, predicate: (x: TSource, index: number) => Promise<boolean>): IAsyncEnumerable<TSource>;
export declare function last_1<T>(source: AsyncIterable<T>): Promise<T>;
export declare function last_2<TSource>(source: AsyncIterable<TSource>, predicate: (x: TSource) => boolean): Promise<TSource>;
export declare function lastOrDefault_1<T>(source: AsyncIterable<T>): Promise<T | null>;
export declare function lastOrDefault_2<T>(source: AsyncIterable<T>, predicate: (x: T) => boolean): Promise<T | null>;
export declare function max_1(source: AsyncIterable<number>): Promise<number>;
export declare function max_2<TSource>(source: AsyncIterable<TSource>, selector: (x: TSource) => number): Promise<number>;
export declare function min_1(source: AsyncIterable<number>): Promise<number>;
export declare function min_2(source: AsyncIterable<number>, selector: (x: number) => number): Promise<number>;
export declare function repeat_1<T>(element: T, count: number): IAsyncEnumerable<T>;
export declare function repeat_2<T>(element: T, count: number, delay: number): IAsyncEnumerable<T>;
export declare function sum_1(source: AsyncIterable<number>): Promise<number>;
export declare function sum_2<TSource>(source: AsyncIterable<TSource>, selector: (x: TSource) => number): Promise<number>;
export declare function takeWhile_1<T>(source: AsyncIterable<T>, predicate: (x: T) => boolean): IAsyncEnumerable<T>;
export declare function takeWhile_2<T>(source: AsyncIterable<T>, predicate: (x: T, index: number) => boolean): IAsyncEnumerable<T>;
export declare function takeWhileAsync_1<T>(source: AsyncIterable<T>, predicate: (x: T) => Promise<boolean>): IAsyncEnumerable<T>;
export declare function takeWhileAsync_2<T>(source: AsyncIterable<T>, predicate: (x: T, index: number) => Promise<boolean>): IAsyncEnumerable<T>;
export declare function union_1<TSource>(first: AsyncIterable<TSource>, second: AsyncIterable<TSource>): BasicAsyncEnumerable<TSource>;
export declare function union_2<TSource>(first: AsyncIterable<TSource>, second: AsyncIterable<TSource>, comparer: IEqualityComparer<TSource>): BasicAsyncEnumerable<TSource>;
export declare function where_1<T>(source: AsyncIterable<T>, predicate: (x: T) => boolean): IAsyncEnumerable<T>;
export declare function where_2<T>(source: AsyncIterable<T>, predicate: (x: T, index: number) => boolean): IAsyncEnumerable<T>;
export declare function whereAsync_1<T>(source: AsyncIterable<T>, predicate: (x: T) => Promise<boolean>): IAsyncEnumerable<T>;
export declare function whereAsync_2<T>(source: AsyncIterable<T>, predicate: (x: T, index: number) => Promise<boolean>): IAsyncEnumerable<T>;
export declare function zip_1<T, Y>(source: AsyncIterable<T>, second: AsyncIterable<Y>): IAsyncEnumerable<ITuple<T, Y>>;
export declare function zip_2<T, Y, OUT>(source: AsyncIterable<T>, second: AsyncIterable<Y>, resultSelector: (x: T, y: Y) => OUT): IAsyncEnumerable<OUT>;
